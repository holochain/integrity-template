#[macro_use]
extern crate lazy_static;

use std::u8;

pub use hdk::prelude::*;

////////////////////////////////////////////////////////////////////////////////
// Entry declarations
////////////////////////////////////////////////////////////////////////////////
// old entry_defs! macro should be able to be deleted because the 
// `hdk_entry` proc macro will create the `EntryTypes` enum

entry_defs![MyThing1::entry_def(), MyThing2::entry_def()];

////////////////////////////////////////////////////////////////////////////////
// Entry struct definitions with necessary impls
////////////////////////////////////////////////////////////////////////////////

#[hdk_entry]
#[derive(Clone)]
pub struct MyThing1 {
    pub thing1: String,
}

#[hdk_entry]
#[derive(Clone)]
pub struct MyThing2 {
    pub thing2: String,
}
impl MyThing2 {
    pub fn some_fn(&self) -> String {
        self.thing2.clone()
    }
}

// entry_types! macro generates the enum below and impls to go in the opposite direction
/// entry_types!([MyThing1, MyThing2]);

// pub enum EntryTypes {
//     #[MyThing1]
//     MyEntry1 = 0,
//     #[MyThing2]
//     MyEntry2
// }


////////////////////////////////////////////////////////////////////////////////
// Link Types
////////////////////////////////////////////////////////////////////////////////

// link_types! macro generates the enum below and impls to go in the opposite direction
/// link_types!([Fish, Dog, Cow]);
pub enum LinkTypes {
    Fish = 0,
    Dog,
    Cow
}

// impl generated by the macro
impl From<LinkType> for LinkTypes {
    fn from(x: LinkType) -> Self {
        match x.0 {
            0 => LinkTypes::Fish,
            1 => LinkTypes::Dog,
            _ => LinkTypes::Cow, // TODO: perhaps TryFrom instead?
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// Genesis self-check callback
////////////////////////////////////////////////////////////////////////////////

#[hdk_extern]
pub fn genesis_self_check(_data: GenesisSelfCheckData) ->  ExternResult<ValidateCallbackResult> {
    // TODO
    // check data.dna_def
    // check data.membrane_proof
    // check data.agent_key
    Ok(ValidateCallbackResult::Valid)
}

////////////////////////////////////////////////////////////////////////////////
// Validation callback
////////////////////////////////////////////////////////////////////////////////

#[hdk_extern]
pub fn validate(op: Op) -> ExternResult<ValidateCallbackResult> {
    let info = zome_info()?;
    match op {
        Op::StoreElement { element } => {
            match element.header() {
                Header::Dna(_) => todo!(),
                Header::AgentValidationPkg(_) => todo!(),
                Header::InitZomesComplete(_) => todo!(),
                Header::CreateLink(create) => match create.link_type.into() {
                    LinkTypes::Fish => todo!(),
                    _ => {}
                },
                Header::DeleteLink(_) => todo!(),
                Header::OpenChain(_) => todo!(),
                Header::CloseChain(_) => todo!(),
                Header::Create(create) => match create.entry_type {
                    EntryType::AgentPubKey => todo!(),
                    EntryType::App( AppEntryType { id, .. } ) => {
                        match info.entry_defs.0.get( id.0 as usize ) {
                            None => return Ok(ValidateCallbackResult::Invalid(format!("failed to find App entry def at index {}", id.0))),
                            Some(entry_def) => match &entry_def.id {
                                EntryDefId::App(name) => match name.as_str() {
                                    "my_entry1" => {},
                                    other => return Ok(ValidateCallbackResult::Invalid(format!("unrecognized App entry {:?}", other))),
                                },
                                EntryDefId::CapClaim => todo!(),
                                EntryDefId::CapGrant => todo!(),
                            }
                        }
                    },
                    EntryType::CapClaim => todo!(),
                    EntryType::CapGrant => todo!(),
                },
                Header::Update(_) => todo!(),
                Header::Delete(_) => todo!(),
            }
            Ok(ValidateCallbackResult::Valid)
        }

        Op::StoreEntry {
            entry: Entry::Agent(_),
            ..
        } => Ok(ValidateCallbackResult::Valid),

        Op::StoreEntry {
            entry,
            header:
                SignedHashed {
                    hashed:
                        HoloHashed {
                            content: entry_creation_header, // EntryCreationHeader
                            ..
                        },
                    ..
                },
        } => __validate_store_entry(entry, entry_creation_header),

        // Validation for links
        Op::RegisterCreateLink {
            create_link:
                SignedHashed {
                    hashed:
                        HoloHashed {
                            content:
                                CreateLink {
                                    link_type, ..
                                },
                            ..
                        },
                    ..
                }
            } => {
            match link_type.into() {
                LinkTypes::Fish => {},
                LinkTypes::Dog => {},
                LinkTypes::Cow => {},
            };
            Ok(ValidateCallbackResult::Valid)
        },
        Op::RegisterDeleteLink {
            delete_link:
                SignedHashed {
                    hashed:
                        HoloHashed {
                            content: _delete_link, ..
                        },
                    ..
                },
            create_link:
                CreateLink {
                    link_type, ..
                },
        } => {
            match link_type.into() {
                LinkTypes::Fish => {},
                LinkTypes::Dog => {},
                LinkTypes::Cow => {},
            };
            Ok(ValidateCallbackResult::Invalid(
                "deleting links isn't valid".to_string(),
            ))
        },
        Op::RegisterUpdate { .. } => Ok(ValidateCallbackResult::Invalid(
            "updating entries isn't valid".to_string(),
        )),
        Op::RegisterDelete { .. } => Ok(ValidateCallbackResult::Invalid(
            "deleting entries isn't valid".to_string(),
        )),
        Op::RegisterAgentActivity { .. } => Ok(ValidateCallbackResult::Valid),
    }
}

fn __validate_store_entry( entry: Entry, entry_creation_header: EntryCreationHeader ) -> ExternResult<ValidateCallbackResult> {

    lazy_static! {
	static ref HOW_ZID: ZomeId = zome_info().unwrap().id;
	static ref MT1_EDI: EntryDefIndex = entry_def_index!(MyThing1).unwrap();
	static ref MT2_EDI: EntryDefIndex = entry_def_index!(MyThing2).unwrap();
    };

    match entry_creation_header {
        EntryCreationHeader::Create( header::Create{entry_type, ..} ) => {
	    if let EntryType::App(app_entry) = entry_type {
                if app_entry.id() == *MT1_EDI {
                    Ok(ValidateCallbackResult::Valid)
                } else if app_entry.id() == *MT2_EDI {
                    let mt2: MyThing2 = entry.try_into()?;
                    match mt2.some_fn().as_str() {
                        "Do something" => Ok(ValidateCallbackResult::Valid),
                        something_else => Ok(ValidateCallbackResult::Invalid(
                            format!("MyThing2 didn't Do something, it did {:?}", something_else)
                        ))
                    }
                } else {
                    Ok(ValidateCallbackResult::Invalid(
                        format!("Some other entry_def_index: {:?}", app_entry.id())
                    ))
                }
            } else {
                Ok(ValidateCallbackResult::Invalid(
                    format!("Not an App entry_type: {:?}", entry_type)
                ))
            }
        },
        EntryCreationHeader::Update( header::Update{entry_hash, entry_type, ..} ) => {
            Ok(ValidateCallbackResult::Invalid(
                format!("Update not allowed for {:?} at {:?}", entry_type, entry_hash)
            ))
        }
    }
}
